import { apiClient } from '../config/api';

export interface Document {
  id: string;
  title: string;
  content: string;
  documentType: string;
  industry: string;
  status: 'Draft' | 'InReview' | 'Approved' | 'Published' | 'Archived';
  publicAccessLevel: 'Private' | 'TenantUsers' | 'AuthenticatedUsers' | 'Public';
  publicSlug?: string;
  publishedAt?: string;
  metaDescription?: string;
  metaKeywords: string[];
  indexBySearchEngines: boolean;
  publicViewCount: number;
  lastPublicViewAt?: string;
  createdAt: string;
  updatedAt: string;
  createdBy: string;
  createdByName?: string;
  tenantId?: string;
  tenantName?: string;
  fileName?: string;
  contentType?: string;
  fileSize?: number;
  fileHash?: string;
  version: number;
  isLatestVersion: boolean;
  parentDocumentId?: string;
  versionNotes?: string;
  tags: DocumentTag[];
  attachments: DocumentAttachment[];
  metadata: DocumentMetadata;
  aiMetadata?: AIMetadata;
}

export interface DocumentTag {
  id: string;
  name: string;
  category: string;
  isSystemGenerated: boolean;
  confidence: number;
}

export interface DocumentAttachment {
  id: string;
  fileName: string;
  contentType: string;
  fileSize: number;
  uploadedAt: string;
  description?: string;
  type: 'File' | 'Audio' | 'Video' | 'Image' | 'Screenshot' | 'SourceCode' | 'Email' | 'Chat';
}

export interface DocumentMetadata {
  properties: Record<string, any>;
  sourceModule?: string;
  sourceAgent?: string;
  sourceCaptureTime?: string;
  sourceLocation?: string;
  keywords: string[];
  summary?: string;
  wordCount: number;
  language?: string;
}

export interface AIMetadata {
  modelUsed?: string;
  confidenceScore: number;
  processedAt: string;
  processingResults: Record<string, any>;
  promptUsed?: string;
  suggestedTags: string[];
  autoGeneratedSummary?: string;
}

export interface DocumentListResponse {
  id: string;
  title: string;
  documentType: string;
  industry: string;
  status: 'Draft' | 'InReview' | 'Approved' | 'Published' | 'Archived';
  createdAt: string;
  updatedAt: string;
  createdByName?: string;
  fileName?: string;
  contentType?: string;
  fileSize?: number;
  version: number;
  isLatestVersion: boolean;
  tagNames: string[];
}

export interface PaginatedResponse<T> {
  items: T[];
  page: number;
  pageSize: number;
  totalItems: number;
  totalPages: number;
  hasNextPage: boolean;
  hasPreviousPage: boolean;
}

export interface DocumentSearchRequest {
  searchTerm?: string;
  tags?: string[];
  documentType?: string;
  industry?: string;
  status?: 'Draft' | 'InReview' | 'Approved' | 'Published' | 'Archived';
  contentType?: string;
  fromDate?: string;
  toDate?: string;
  createdBy?: string;
  page: number;
  pageSize: number;
}

export interface CreateDocumentRequest {
  title: string;
  content: string;
  documentType: string;
  industry: string;
  status: 'Draft' | 'InReview' | 'Approved' | 'Published';
  publicAccessLevel: 'Private' | 'TenantUsers' | 'AuthenticatedUsers' | 'Public';
  publicSlug?: string;
  metaDescription?: string;
  metaKeywords: string[];
  indexBySearchEngines: boolean;
  fileName?: string;
  contentType?: string;
  fileSize?: number;
  versionNotes?: string;
  tags?: string[];
}

export interface UpdateDocumentRequest {
  title?: string;
  content?: string;
  documentType?: string;
  industry?: string;
  status?: 'Draft' | 'InReview' | 'Approved' | 'Published';
  publicAccessLevel?: 'Private' | 'TenantUsers' | 'AuthenticatedUsers' | 'Public';
  publicSlug?: string;
  metaDescription?: string;
  metaKeywords?: string[];
  indexBySearchEngines?: boolean;
  versionNotes?: string;
  tags?: string[];
}

export interface DocumentUploadRequest extends FormData {
  file: File;
  title?: string;
  description?: string;
  documentType?: string;
  industry?: string;
  status: 'Draft' | 'InReview' | 'Approved' | 'Published';
  publicAccessLevel: 'Private' | 'TenantUsers' | 'AuthenticatedUsers' | 'Public';
  tags?: string[];
}

export interface CreateDocumentVersionRequest {
  content?: string;
  status?: 'Draft' | 'InReview' | 'Approved' | 'Published';
  versionNotes?: string;
  tags?: string[];
}

class DocumentService {
  private baseUrl = '/api/documents';

  async getDocuments(request: DocumentSearchRequest): Promise<PaginatedResponse<DocumentListResponse>> {
    const params = new URLSearchParams();
    
    if (request.searchTerm) params.append('searchTerm', request.searchTerm);
    if (request.documentType) params.append('documentType', request.documentType);
    if (request.industry) params.append('industry', request.industry);
    if (request.status) params.append('status', request.status);
    if (request.contentType) params.append('contentType', request.contentType);
    if (request.fromDate) params.append('fromDate', request.fromDate);
    if (request.toDate) params.append('toDate', request.toDate);
    if (request.createdBy) params.append('createdBy', request.createdBy);
    if (request.tags) request.tags.forEach(tag => params.append('tags', tag));
    
    params.append('page', request.page.toString());
    params.append('pageSize', request.pageSize.toString());

    const response = await apiClient.get<PaginatedResponse<DocumentListResponse>>(`${this.baseUrl}?${params.toString()}`);
    return response.data;
  }

  async getDocument(id: string): Promise<Document> {
    const response = await apiClient.get<Document>(`${this.baseUrl}/${id}`);
    return response.data;
  }

  async createDocument(request: CreateDocumentRequest): Promise<Document> {
    const response = await apiClient.post<Document>(this.baseUrl, request);
    return response.data;
  }

  async updateDocument(id: string, request: UpdateDocumentRequest): Promise<Document> {
    const response = await apiClient.put<Document>(`${this.baseUrl}/${id}`, request);
    return response.data;
  }

  async deleteDocument(id: string): Promise<void> {
    await apiClient.delete(`${this.baseUrl}/${id}`);
  }

  async getDocumentVersions(id: string): Promise<DocumentListResponse[]> {
    const response = await apiClient.get<DocumentListResponse[]>(`${this.baseUrl}/${id}/versions`);
    return response.data;
  }

  async createDocumentVersion(id: string, request: CreateDocumentVersionRequest): Promise<Document> {
    const response = await apiClient.post<Document>(`${this.baseUrl}/${id}/versions`, request);
    return response.data;
  }

  async getLatestVersion(id: string): Promise<Document> {
    const response = await apiClient.get<Document>(`${this.baseUrl}/${id}/latest`);
    return response.data;
  }

  async uploadDocument(formData: FormData): Promise<Document> {
    const response = await fetch(`${this.baseUrl}/upload`, {
      method: 'POST',
      body: formData,
    });
    return response.json();
  }

  async downloadDocument(id: string): Promise<Blob> {
    const response = await fetch(`${this.baseUrl}/${id}/download`);
    return response.blob();
  }

  async getFileInfo(id: string): Promise<any> {
    const response = await apiClient.get(`${this.baseUrl}/${id}/file-info`);
    return response.data;
  }

  // Helper methods
  async uploadFiles(files: File[], metadata: Partial<CreateDocumentRequest> = {}): Promise<Document[]> {
    const uploadPromises = files.map(async (file) => {
      const formData = new FormData();
      formData.append('file', file);
      
      // Add metadata
      if (metadata.title) formData.append('title', metadata.title);
      if (metadata.documentType) formData.append('documentType', metadata.documentType);
      if (metadata.industry) formData.append('industry', metadata.industry);
      if (metadata.status) formData.append('status', metadata.status);
      if (metadata.publicAccessLevel) formData.append('publicAccessLevel', metadata.publicAccessLevel);
      if (metadata.content) formData.append('description', metadata.content);
      if (metadata.tags) {
        metadata.tags.forEach(tag => formData.append('tags', tag));
      }

      return this.uploadDocument(formData);
    });

    return Promise.all(uploadPromises);
  }

  downloadDocumentAsFile(id: string, fileName?: string): Promise<void> {
    return this.downloadDocument(id).then(blob => {
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = fileName || 'document';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
    });
  }

  formatFileSize(bytes?: number): string {
    if (!bytes) return 'Unknown';
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
  }

  getStatusColor(status: string): string {
    switch (status) {
      case 'Draft': return 'bg-gray-100 text-gray-800';
      case 'InReview': return 'bg-yellow-100 text-yellow-800';
      case 'Approved': return 'bg-green-100 text-green-800';
      case 'Published': return 'bg-blue-100 text-blue-800';
      case 'Archived': return 'bg-purple-100 text-purple-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  }

  getFileTypeIcon(contentType?: string): string {
    if (!contentType) return 'üìÑ';
    if (contentType.includes('image')) return 'üñºÔ∏è';
    if (contentType.includes('pdf')) return 'üìÑ';
    if (contentType.includes('word') || contentType.includes('document')) return 'üìù';
    if (contentType.includes('excel') || contentType.includes('spreadsheet')) return 'üìä';
    if (contentType.includes('powerpoint') || contentType.includes('presentation')) return 'üìë';
    if (contentType.includes('text')) return 'üìÑ';
    return 'üìÑ';
  }
}

export const documentService = new DocumentService();