using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Caching.Memory;
using EnterpriseDocsCore.Domain.Entities;
using EnterpriseDocsCore.Domain.Interfaces;
using EnterpriseDocsCore.Infrastructure.Data;

namespace EnterpriseDocsCore.Infrastructure.Services;

public class DocumentService : IDocumentService
{
    private readonly ApplicationDbContext _context;
    private readonly ILogger<DocumentService> _logger;
    private readonly IMemoryCache _cache;
    private readonly IAIService _aiService;
    private readonly IStorageService _storageService;

    public DocumentService(
        ApplicationDbContext context,
        ILogger<DocumentService> logger,
        IMemoryCache cache,
        IAIService aiService,
        IStorageService storageService)
    {
        _context = context;
        _logger = logger;
        _cache = cache;
        _aiService = aiService;
        _storageService = storageService;
    }

    public async Task<Document> CreateDocumentAsync(CreateDocumentRequest request, Guid userId, CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("Creating document '{Title}' for user {UserId}", request.Title, userId);

        var user = await _context.Users.FindAsync(userId);
        if (user == null)
        {
            throw new ArgumentException("User not found", nameof(userId));
        }

        var document = new Document
        {
            Title = request.Title,
            Content = request.Content,
            DocumentType = request.DocumentType,
            Industry = request.Industry,
            Status = DocumentStatus.Draft,
            CreatedBy = userId,
            TenantId = user.TenantId,
            ParentDocumentId = request.ParentDocumentId,
            Metadata = request.Metadata ?? new DocumentMetadata
            {
                Language = "en",
                WordCount = CountWords(request.Content)
            }
        };

        // Add tags
        foreach (var tagName in request.Tags)
        {
            document.Tags.Add(new DocumentTag
            {
                Name = tagName,
                Category = "user",
                IsSystemGenerated = false,
                Confidence = 1.0f
            });
        }

        // Process with AI if enabled
        if (user.Settings.EnableAIAssistance)
        {
            try
            {
                var aiResult = await _aiService.AnalyzeContentAsync(request.Content, cancellationToken: cancellationToken);
                
                // Add AI-generated tags
                foreach (var suggestedTag in aiResult.TopicSummary.Take(5))
                {
                    if (!document.Tags.Any(t => t.Name.Equals(suggestedTag, StringComparison.OrdinalIgnoreCase)))
                    {
                        document.Tags.Add(new DocumentTag
                        {
                            Name = suggestedTag,
                            Category = "ai",
                            IsSystemGenerated = true,
                            Confidence = 0.8f
                        });
                    }
                }

                // Set AI metadata
                document.AIMetadata = new AIMetadata
                {
                    ModelUsed = "content-analyzer",
                    ConfidenceScore = aiResult.Sentiment.ConfidenceScore,
                    ProcessingResults = new Dictionary<string, object>
                    {
                        ["readabilityScore"] = aiResult.ReadabilityScore,
                        ["sentiment"] = aiResult.Sentiment.Overall.ToString(),
                        ["topics"] = aiResult.TopicSummary
                    },
                    SuggestedTags = aiResult.TopicSummary,
                    AutoGeneratedSummary = aiResult.TopicSummary.FirstOrDefault()
                };

                // Update metadata with AI insights
                document.Metadata.Keywords = aiResult.TopicSummary;
                document.Metadata.Summary = aiResult.TopicSummary.FirstOrDefault();
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to process document with AI for document {Title}", request.Title);
            }
        }

        // Handle attachments
        foreach (var attachmentRequest in request.Attachments)
        {
            var storagePath = await _storageService.SaveFileAsync(attachmentRequest.FileStream, attachmentRequest.FileName, cancellationToken);
            
            document.Attachments.Add(new DocumentAttachment
            {
                FileName = attachmentRequest.FileName,
                ContentType = attachmentRequest.ContentType,
                FileSize = attachmentRequest.FileStream.Length,
                StoragePath = storagePath,
                UploadedBy = userId,
                Description = attachmentRequest.Description,
                Type = attachmentRequest.Type
            });
        }

        // Add audit entry
        document.AuditEntries.Add(new DocumentAuditEntry
        {
            Action = "Created",
            UserId = userId,
            Details = $"Document created with type '{request.DocumentType}'"
        });

        _context.Documents.Add(document);
        await _context.SaveChangesAsync(cancellationToken);

        _logger.LogInformation("Document '{Title}' created successfully with ID {DocumentId}", document.Title, document.Id);

        return document;
    }

    public async Task<Document?> GetDocumentByIdAsync(Guid id, Guid? userId = null, CancellationToken cancellationToken = default)
    {
        var cacheKey = $"document:{id}:{userId}";
        
        if (_cache.TryGetValue(cacheKey, out Document? cachedDocument))
        {
            return cachedDocument;
        }

        var query = _context.Documents
            .Include(d => d.CreatedByUser)
            .Include(d => d.Tags)
            .Include(d => d.Attachments)
            .Include(d => d.Permissions)
                .ThenInclude(p => p.User)
            .Include(d => d.Permissions)
                .ThenInclude(p => p.Role)
            .AsQueryable();

        var document = await query.FirstOrDefaultAsync(d => d.Id == id, cancellationToken);

        if (document == null)
        {
            return null;
        }

        // Check permissions if userId is provided
        if (userId.HasValue && !await HasPermissionAsync(id, userId.Value, PermissionType.Read, cancellationToken))
        {
            return null;
        }

        // Record view if userId is provided
        if (userId.HasValue)
        {
            await RecordDocumentViewAsync(id, userId.Value, cancellationToken);
        }

        // Cache for 5 minutes
        _cache.Set(cacheKey, document, TimeSpan.FromMinutes(5));

        return document;
    }

    public async Task<Document> UpdateDocumentAsync(Guid id, UpdateDocumentRequest request, Guid userId, CancellationToken cancellationToken = default)
    {
        var document = await _context.Documents
            .Include(d => d.Tags)
            .Include(d => d.AuditEntries)
            .FirstOrDefaultAsync(d => d.Id == id, cancellationToken);

        if (document == null)
        {
            throw new ArgumentException("Document not found", nameof(id));
        }

        if (!await HasPermissionAsync(id, userId, PermissionType.Write, cancellationToken))
        {
            throw new UnauthorizedAccessException("User does not have permission to edit this document");
        }

        var changes = new List<string>();

        if (!string.IsNullOrEmpty(request.Title) && request.Title != document.Title)
        {
            changes.Add($"Title changed from '{document.Title}' to '{request.Title}'");
            document.Title = request.Title;
        }

        if (!string.IsNullOrEmpty(request.Content) && request.Content != document.Content)
        {
            changes.Add("Content updated");
            document.Content = request.Content;
            document.Metadata.WordCount = CountWords(request.Content);
        }

        if (!string.IsNullOrEmpty(request.DocumentType) && request.DocumentType != document.DocumentType)
        {
            changes.Add($"Document type changed from '{document.DocumentType}' to '{request.DocumentType}'");
            document.DocumentType = request.DocumentType;
        }

        if (request.Status.HasValue && request.Status != document.Status)
        {
            changes.Add($"Status changed from '{document.Status}' to '{request.Status}'");
            document.Status = request.Status.Value;
        }

        if (request.Tags != null)
        {
            // Remove existing user tags
            var userTags = document.Tags.Where(t => !t.IsSystemGenerated).ToList();
            foreach (var tag in userTags)
            {
                _context.DocumentTags.Remove(tag);
            }

            // Add new tags
            foreach (var tagName in request.Tags)
            {
                document.Tags.Add(new DocumentTag
                {
                    Name = tagName,
                    Category = "user",
                    IsSystemGenerated = false,
                    Confidence = 1.0f
                });
            }

            changes.Add("Tags updated");
        }

        if (request.Metadata != null)
        {
            document.Metadata = request.Metadata;
            changes.Add("Metadata updated");
        }

        // Add audit entry
        document.AuditEntries.Add(new DocumentAuditEntry
        {
            Action = "Updated",
            UserId = userId,
            Details = string.Join("; ", changes)
        });

        await _context.SaveChangesAsync(cancellationToken);

        // Clear cache
        _cache.Remove($"document:{id}:{userId}");

        _logger.LogInformation("Document {DocumentId} updated by user {UserId}. Changes: {Changes}", 
            id, userId, string.Join("; ", changes));

        return document;
    }

    public async Task<bool> DeleteDocumentAsync(Guid id, Guid userId, CancellationToken cancellationToken = default)
    {
        var document = await _context.Documents.FindAsync(id);
        if (document == null)
        {
            return false;
        }

        if (!await HasPermissionAsync(id, userId, PermissionType.Delete, cancellationToken))
        {
            throw new UnauthorizedAccessException("User does not have permission to delete this document");
        }

        // Soft delete
        document.Status = DocumentStatus.Deleted;

        // Add audit entry
        document.AuditEntries.Add(new DocumentAuditEntry
        {
            Action = "Deleted",
            UserId = userId,
            Details = "Document moved to deleted status"
        });

        await _context.SaveChangesAsync(cancellationToken);

        // Clear cache
        _cache.Remove($"document:{id}:{userId}");

        _logger.LogInformation("Document {DocumentId} deleted by user {UserId}", id, userId);

        return true;
    }

    public async Task<PagedResult<Document>> GetDocumentsAsync(DocumentFilter filter, Guid? userId = null, CancellationToken cancellationToken = default)
    {
        var query = _context.Documents
            .Include(d => d.CreatedByUser)
            .Include(d => d.Tags)
            .AsQueryable();

        // Apply filters
        if (filter.TenantId.HasValue)
        {
            query = query.Where(d => d.TenantId == filter.TenantId);
        }

        if (!string.IsNullOrEmpty(filter.Search))
        {
            query = query.Where(d => d.Title.Contains(filter.Search) || d.Content.Contains(filter.Search));
        }

        if (!string.IsNullOrEmpty(filter.DocumentType))
        {
            query = query.Where(d => d.DocumentType == filter.DocumentType);
        }

        if (!string.IsNullOrEmpty(filter.Industry))
        {
            query = query.Where(d => d.Industry == filter.Industry);
        }

        if (filter.Status.HasValue)
        {
            query = query.Where(d => d.Status == filter.Status);
        }

        if (filter.CreatedBy.HasValue)
        {
            query = query.Where(d => d.CreatedBy == filter.CreatedBy);
        }

        if (filter.DateFrom.HasValue)
        {
            query = query.Where(d => d.CreatedAt >= filter.DateFrom);
        }

        if (filter.DateTo.HasValue)
        {
            query = query.Where(d => d.CreatedAt <= filter.DateTo);
        }

        if (filter.Tags.Any())
        {
            query = query.Where(d => d.Tags.Any(t => filter.Tags.Contains(t.Name)));
        }

        // Apply sorting
        query = filter.SortBy?.ToLower() switch
        {
            "title" => filter.SortOrder == SortOrder.Ascending 
                ? query.OrderBy(d => d.Title) 
                : query.OrderByDescending(d => d.Title),
            "createdat" => filter.SortOrder == SortOrder.Ascending 
                ? query.OrderBy(d => d.CreatedAt) 
                : query.OrderByDescending(d => d.CreatedAt),
            "updatedat" => filter.SortOrder == SortOrder.Ascending 
                ? query.OrderBy(d => d.UpdatedAt) 
                : query.OrderByDescending(d => d.UpdatedAt),
            _ => query.OrderByDescending(d => d.UpdatedAt)
        };

        var totalItems = await query.CountAsync(cancellationToken);
        var totalPages = (int)Math.Ceiling((double)totalItems / filter.PageSize);

        var documents = await query
            .Skip((filter.Page - 1) * filter.PageSize)
            .Take(filter.PageSize)
            .ToListAsync(cancellationToken);

        // Filter by permissions if userId is provided
        if (userId.HasValue)
        {
            var accessibleDocuments = new List<Document>();
            foreach (var document in documents)
            {
                if (await HasPermissionAsync(document.Id, userId.Value, PermissionType.Read, cancellationToken))
                {
                    accessibleDocuments.Add(document);
                }
            }
            documents = accessibleDocuments;
        }

        return new PagedResult<Document>
        {
            Items = documents,
            Page = filter.Page,
            PageSize = filter.PageSize,
            TotalPages = totalPages,
            TotalItems = totalItems
        };
    }

    public async Task<List<Document>> GetRecentDocumentsAsync(Guid userId, int count = 10, CancellationToken cancellationToken = default)
    {
        var user = await _context.Users.FindAsync(userId);
        if (user == null)
        {
            return new List<Document>();
        }

        var documents = await _context.Documents
            .Include(d => d.CreatedByUser)
            .Include(d => d.Tags)
            .Where(d => d.TenantId == user.TenantId && 
                       (d.CreatedBy == userId || 
                        d.Permissions.Any(p => p.UserId == userId || 
                                             (p.Role != null && p.Role.UserRoles.Any(ur => ur.UserId == userId)))))
            .OrderByDescending(d => d.UpdatedAt)
            .Take(count)
            .ToListAsync(cancellationToken);

        return documents;
    }

    public async Task<List<Document>> SearchDocumentsAsync(string query, DocumentFilter? filter = null, Guid? userId = null, CancellationToken cancellationToken = default)
    {
        var searchQuery = _context.Documents
            .Include(d => d.CreatedByUser)
            .Include(d => d.Tags)
            .Where(d => d.Title.Contains(query) || 
                       d.Content.Contains(query) || 
                       d.Tags.Any(t => t.Name.Contains(query)))
            .AsQueryable();

        if (filter != null)
        {
            if (filter.TenantId.HasValue)
            {
                searchQuery = searchQuery.Where(d => d.TenantId == filter.TenantId);
            }

            if (!string.IsNullOrEmpty(filter.DocumentType))
            {
                searchQuery = searchQuery.Where(d => d.DocumentType == filter.DocumentType);
            }

            if (!string.IsNullOrEmpty(filter.Industry))
            {
                searchQuery = searchQuery.Where(d => d.Industry == filter.Industry);
            }
        }

        var documents = await searchQuery
            .OrderByDescending(d => d.UpdatedAt)
            .Take(50) // Limit search results
            .ToListAsync(cancellationToken);

        // Filter by permissions if userId is provided
        if (userId.HasValue)
        {
            var accessibleDocuments = new List<Document>();
            foreach (var document in documents)
            {
                if (await HasPermissionAsync(document.Id, userId.Value, PermissionType.Read, cancellationToken))
                {
                    accessibleDocuments.Add(document);
                }
            }
            documents = accessibleDocuments;
        }

        return documents;
    }

    public async Task<bool> HasPermissionAsync(Guid documentId, Guid userId, PermissionType permission, CancellationToken cancellationToken = default)
    {
        var document = await _context.Documents.FindAsync(documentId);
        if (document == null)
        {
            return false;
        }

        // Owner has all permissions
        if (document.CreatedBy == userId)
        {
            return true;
        }

        // Check explicit document permissions
        var hasDirectPermission = await _context.DocumentPermissions
            .AnyAsync(p => p.DocumentId == documentId && 
                          p.UserId == userId && 
                          p.Permission >= permission &&
                          (p.ExpiresAt == null || p.ExpiresAt > DateTime.UtcNow), 
                     cancellationToken);

        if (hasDirectPermission)
        {
            return true;
        }

        // Check role-based permissions
        var hasRolePermission = await _context.DocumentPermissions
            .Include(p => p.Role)
                .ThenInclude(r => r!.UserRoles)
            .AnyAsync(p => p.DocumentId == documentId && 
                          p.RoleId != null &&
                          p.Role!.UserRoles.Any(ur => ur.UserId == userId && ur.IsActive) &&
                          p.Permission >= permission &&
                          (p.ExpiresAt == null || p.ExpiresAt > DateTime.UtcNow), 
                     cancellationToken);

        return hasRolePermission;
    }

    public async Task RecordDocumentViewAsync(Guid documentId, Guid userId, CancellationToken cancellationToken = default)
    {
        var auditEntry = new DocumentAuditEntry
        {
            DocumentId = documentId,
            Action = "Viewed",
            UserId = userId,
            Details = "Document viewed"
        };

        _context.DocumentAuditEntries.Add(auditEntry);
        await _context.SaveChangesAsync(cancellationToken);
    }

    // Additional methods would be implemented here following the same pattern...
    // For brevity, I'm showing the core CRUD and permission methods

    private static int CountWords(string content)
    {
        if (string.IsNullOrWhiteSpace(content))
        {
            return 0;
        }

        return content.Split(new[] { ' ', '\t', '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries).Length;
    }

    // Placeholder implementations for remaining interface methods
    public Task<List<Document>> GetDocumentVersionsAsync(Guid documentId, Guid? userId = null, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<Document> CreateDocumentVersionAsync(Guid documentId, string content, Guid userId, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<Document> RestoreDocumentVersionAsync(Guid documentId, int version, Guid userId, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<List<DocumentPermission>> GetDocumentPermissionsAsync(Guid documentId, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<DocumentPermission> GrantPermissionAsync(Guid documentId, GrantPermissionRequest request, Guid grantedBy, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<bool> RevokePermissionAsync(Guid documentId, Guid permissionId, Guid revokedBy, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<ShareLink> CreateShareLinkAsync(Guid documentId, ShareLinkRequest request, Guid userId, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<Document?> GetDocumentByShareLinkAsync(string shareToken, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<bool> RevokeShareLinkAsync(Guid documentId, string shareToken, Guid userId, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<List<DocumentTag>> GetDocumentTagsAsync(Guid documentId, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<DocumentTag> AddTagAsync(Guid documentId, string tagName, string? category = null, Guid? userId = null, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<bool> RemoveTagAsync(Guid documentId, Guid tagId, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<List<string>> GetPopularTagsAsync(Guid? tenantId = null, int count = 50, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<List<DocumentAttachment>> GetDocumentAttachmentsAsync(Guid documentId, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<DocumentAttachment> AddAttachmentAsync(Guid documentId, AttachmentRequest request, Guid userId, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<bool> RemoveAttachmentAsync(Guid documentId, Guid attachmentId, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<Stream> GetAttachmentStreamAsync(Guid attachmentId, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<Stream> ExportDocumentAsync(Guid documentId, ExportFormat format, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<Stream> ExportDocumentsAsync(List<Guid> documentIds, ExportFormat format, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<DocumentAnalytics> GetDocumentAnalyticsAsync(Guid documentId, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<List<DocumentActivity>> GetDocumentActivityAsync(Guid documentId, int count = 50, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<List<DocumentTemplate>> GetDocumentTemplatesAsync(string? industry = null, string? documentType = null, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<Document> CreateFromTemplateAsync(Guid templateId, CreateFromTemplateRequest request, Guid userId, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<BulkOperationResult> BulkUpdateStatusAsync(List<Guid> documentIds, DocumentStatus status, Guid userId, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<BulkOperationResult> BulkDeleteAsync(List<Guid> documentIds, Guid userId, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }

    public Task<BulkOperationResult> BulkAddTagAsync(List<Guid> documentIds, string tagName, Guid userId, CancellationToken cancellationToken = default)
    {
        throw new NotImplementedException();
    }
}

// Storage service interface for file handling
public interface IStorageService
{
    Task<string> SaveFileAsync(Stream fileStream, string fileName, CancellationToken cancellationToken = default);
    Task<Stream> GetFileAsync(string storagePath, CancellationToken cancellationToken = default);
    Task<bool> DeleteFileAsync(string storagePath, CancellationToken cancellationToken = default);
}